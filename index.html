<!DOCTYPE html>
<html lang="fr">
<head>
    <link rel="icon" href="favicon.png" type="image/png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LAN Demain 🚀</title>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

    <style>

/* --- Style pour les notifications Toast --- */
#toast-container {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 2000;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 10px;
}

.toast {
    padding: 15px 20px;
    border-radius: 8px;
    color: white;
    font-weight: bold;
    box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    transform: translateX(120%);
    opacity: 0;
    transition: transform 0.5s ease, opacity 0.5s ease;
}

.toast.show {
    transform: translateX(0);
    opacity: 1;
}

.toast.success {
    background-color: var(--accent-color);
    color: var(--dark-bg);
}

.toast.error {
    background-color: var(--danger-color);
}
        :root {
            --dark-bg: #121212;
            --card-bg: #1e1e1e;
            --primary-text: #bb86fc;
            --secondary-text: #e0e0e0;
            --border-color: #333333;
            --accent-color: #03dac6;
            --danger-color: #cf6679;
            --gold: #ffd700;
            --silver: #c0c0c0;
            --bronze: #cd7f32;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body { font-family: 'Inter', sans-serif; background-color: var(--dark-bg); color: var(--secondary-text); margin: 0; padding: 25px; }
        .container { width: 100%; max-width: 1200px; margin: 0 auto; }
        h1, h2, h3 { color: var(--primary-text); text-align: center; }
        h1 { font-size: 2.5em; text-shadow: 0 0 10px var(--primary-text); animation: fadeInDown 0.8s ease-out; }
        h2 { border-bottom: 2px solid var(--border-color); padding-bottom: 10px; margin-bottom: 25px; }

        @keyframes fadeInDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes growBar { from { transform: scaleY(0); } to { transform: scaleY(1); } }
        @keyframes pulse { 0% { box-shadow: 0 0 4px var(--glow-color); } 50% { box-shadow: 0 0 16px var(--glow-color); } 100% { box-shadow: 0 0 4px var(--glow-color); } }
        
        .animated-section { animation: fadeInUp 0.8s ease-out forwards; opacity: 0; }
        
        #auth-container { max-width: 400px; margin: 50px auto; padding: 30px; background-color: var(--card-bg); border-radius: 12px; text-align: center; border: 1px solid var(--border-color); }
        #google-login-btn { background-color: #4285F4; color: white; border: none; padding: 12px 20px; font-size: 1.1em; font-weight: bold; border-radius: 4px; cursor: pointer; display: inline-flex; align-items: center; gap: 10px; transition: background-color 0.3s; }
        #google-login-btn:hover { background-color: #357ae8; }
        #google-login-btn:disabled { background-color: #333; cursor: not-allowed; }
        #google-login-btn svg { width: 20px; height: 20px; }
        #login-spinner { display: none; border: 2px solid #f3f3f3; border-top: 2px solid var(--accent-color); border-radius: 50%; width: 18px; height: 18px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #app-container { display: none; }

        .kpi-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 20px; margin-bottom: 40px; }
        .kpi-card { background-color: var(--card-bg); border: 1px solid var(--border-color); border-radius: 12px; padding: 20px; text-align: center; box-shadow: 0 6px 20px rgba(0,0,0,0.5); transition: transform 0.3s ease, box-shadow 0.3s ease; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .kpi-card:hover { transform: translateY(-5px); box-shadow: 0 8px 25px rgba(187, 134, 252, 0.3); }
        .kpi-card-title { font-size: 1em; margin-bottom: 10px; color: #a0a0c0; }
        .kpi-card-value { font-size: 2.2em; font-weight: bold; color: var(--secondary-text); }
        #kpi-winner-value { color: var(--gold); }
        #winner-image { max-width: 100%; height: 69px; border-radius: 4px; margin-bottom: 10px; opacity: 0; transition: opacity 0.5s; object-fit: cover; }
        #winner-image.loaded { opacity: 1; }

        .main-content { display: grid; grid-template-columns: repeat(2, 1fr); gap: 25px; margin-bottom: 40px; }
        .results-container, .form-container, .chart-wrapper { background-color: var(--card-bg); border: 1px solid var(--border-color); border-radius: 12px; padding: 25px; box-shadow: 0 6px 20px rgba(0,0,0,0.5); }
        .chart-wrapper { grid-column: 1 / -1; }

        #chart-container { display: flex; justify-content: space-around; align-items: flex-end; height: 300px; width: 100%; border-left: 2px solid var(--border-color); border-bottom: 2px solid var(--border-color); padding: 0 10px; }
        .chart-bar-group { display: flex; flex-direction: column; align-items: center; height: 100%; justify-content: flex-end; flex-grow: 1; padding: 0 5px; }
        .chart-bar { width: 75%; background: linear-gradient(to top, var(--accent-color), var(--primary-text)); border-radius: 5px 5px 0 0; animation: growBar 1s ease-out forwards; transform-origin: bottom; position: relative; }
        .chart-bar-group.gold .chart-bar { background: linear-gradient(to top, #ffc400, #fff2b2); --glow-color: var(--gold); animation: growBar 1s ease-out forwards, pulse 2s infinite 1s; }
        .chart-bar-group.silver .chart-bar { background: linear-gradient(to top, #b0b0b0, #e0e0e0); }
        .chart-bar-group.bronze .chart-bar { background: linear-gradient(to top, #cd7f32, #e8b382); }
        .chart-bar .bar-label { position: absolute; top: -25px; width: 100%; text-align: center; font-weight: bold; }
        .chart-game-name { margin-top: 10px; font-size: 0.9em; white-space: nowrap; }

        .results-table { width: 100%; border-collapse: collapse; }
        .results-table th, .results-table td { padding: 14px 10px; text-align: left; vertical-align: middle; }
        .results-table thead { border-bottom: 2px solid var(--border-color); }
        .results-table tbody tr { opacity: 0; animation: fadeInUp 0.5s ease-out forwards; }
        .results-table tbody tr.gold { --row-accent: var(--gold); }
        .results-table tbody tr.silver { --row-accent: var(--silver); }
        .results-table tbody tr.bronze { --row-accent: var(--bronze); }
        .results-table tbody tr.gold, .results-table tbody tr.silver, .results-table tbody tr.bronze { background: linear-gradient(90deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0) 100%); border-left: 4px solid var(--row-accent, transparent); }
        .game-icon { width: 46px; height: 21px; border-radius: 2px; margin-right: 10px; vertical-align: middle; object-fit: cover; }
        
        #voter-management { margin-bottom: 20px; }
        #voter-select-menu { width: 100%; padding: 10px; background-color: var(--dark-bg); color: var(--secondary-text); border: 1px solid var(--border-color); border-radius: 4px; }

        #vote-form { display: flex; flex-direction: column; gap: 20px; }
        .priority-group { background-color: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color); }
        .priority-group h3 { margin: 0 0 15px 0; color: var(--accent-color); text-align: left; }
        .game-input-list { display: flex; flex-direction: column; gap: 10px; }

        /* --- CSS CORRIGÉ ET STABILISÉ POUR LE FORMULAIRE --- */
        .game-input-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .game-input-wrapper input {
            flex-grow: 1;
            padding: 8px 12px;
            background-color: var(--dark-bg);
            color: var(--secondary-text);
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        .steam-search-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            opacity: 0.6;
            transition: opacity 0.2s;
            flex-shrink: 0;
        }
        .steam-search-btn:hover {
            opacity: 1;
        }
        .steam-search-btn svg {
            width: 20px;
            height: 20px;
            fill: var(--secondary-text);
        }
        .add-game-btn, .remove-game-btn { 
            background-color: var(--border-color); 
            color: var(--secondary-text); 
            border: none; 
            border-radius: 50%; 
            width: 28px; 
            height: 28px; 
            cursor: pointer; 
            font-weight: bold; 
            font-size: 1.2em; 
            line-height: 28px; 
            text-align: center; 
            flex-shrink: 0; 
            transition: background-color 0.3s, transform 0.3s; 
        }
        .add-game-btn:hover, .remove-game-btn:hover { background-color: var(--accent-color); color: var(--dark-bg); transform: rotate(90deg); }
        .remove-game-btn:hover { transform: rotate(180deg); }
        
        .form-actions { display: flex; gap: 10px; }
        #submit-vote-btn { 
            padding: 14px; 
            border: none; 
            border-radius: 8px; 
            color: black; 
            font-size: 1.2em; 
            font-weight: bold; 
            cursor: pointer; 
            flex-grow: 1; 
            transition: transform 0.2s, box-shadow 0.2s;
            background-color: var(--accent-color); 
        }
        #submit-vote-btn:hover { transform: scale(1.02); box-shadow: 0 0 15px var(--accent-color); }

        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 1000; animation: fadeInDown 0.3s; }
        .modal-content { background-color: var(--card-bg); padding: 30px; border-radius: 12px; border: 1px solid var(--border-color); max-width: 500px; width: 90%; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .modal-content h3 { margin-top: 0; color: var(--primary-text); }
        #suggestions-list { list-style: none; padding: 0; margin: 20px 0; }
        #suggestions-list li { margin-bottom: 10px; }
        #suggestions-list li em { color: var(--danger-color); font-style: normal; }
        #suggestions-list li strong { color: var(--accent-color); }
        .modal-actions { display: flex; justify-content: space-between; gap: 10px; }
        .modal-actions button { flex-grow: 1; padding: 12px; border-radius: 8px; border: none; font-weight: bold; cursor: pointer; }
        #modal-accept { background-color: var(--accent-color); color: black; }
        #modal-ignore { background-color: var(--border-color); color: var(--secondary-text); }
        #modal-cancel { background-color: transparent; color: var(--secondary-text); border: 1px solid var(--border-color); }
        
        #user-info { display: flex; align-items: center; justify-content: flex-end; gap: 15px; margin-bottom: 20px; }
        #user-avatar { width: 32px; height: 32px; border-radius: 50%; }

        @media (max-width: 768px) {
            body { padding: 15px; }
            h1 { font-size: 1.8em; }
            h2 { font-size: 1.3em; }
            .kpi-grid { grid-template-columns: 1fr 1fr; }
            .kpi-card-value { font-size: 1.8em; }
            .main-content { grid-template-columns: 1fr; }
            .chart-wrapper { overflow-x: auto; padding-right: 15px;}
            #chart-container { min-width: 650px; }
            .chart-game-name { white-space: normal; text-align: center; font-size: 0.8em; }
        }

        #active-users-sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: 60px;
            height: 100%;
            background-color: var(--card-bg);
            border-right: 1px solid var(--border-color);
            padding-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            overflow-y: auto;
            z-index: 100;
            transition: transform 0.3s ease;
            transform: translateX(-100%);
        }
        #active-users-sidebar.visible {
            transform: translateX(0);
        }
        #active-users-sidebar .user-avatar-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--accent-color);
        }
        body.sidebar-visible {
            padding-left: 60px;
        }
    </style>
</head>
<body>
	<div id="active-users-sidebar"></div>

     <div id="auth-container">
        <h1>LAN Demain</h1>
        <p>Connecte-toi pour organiser la meilleure LAN !</p>
        <button id="google-login-btn">
            <svg id="google-icon" style="width: 20px; height: 20px;" viewBox="0 0 24 24" fill="white"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/><path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/></svg>
            <span id="login-btn-text">Se connecter avec Google</span>
            <div id="login-spinner"></div>
        </button>
        <p id="auth-error" style="color: var(--danger-color); margin-top: 15px;"></p>
    </div>
    
    <div id="app-container" style="display: none;">
        <div class="container">
            <header>
                <div id="user-info">
                    <span id="user-name"></span>
                    <img id="user-avatar" src="" alt="Avatar">
                    <button id="logout-btn" style="background-color: var(--danger-color); color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;">Déconnexion</button>
                </div>
                <h1>LAN Demain 🚀 Le Sélecteur</h1>
            </header>

            <section class="kpi-grid animated-section">
                <div class="kpi-card">
                    <div class="kpi-card-title">🏆 Jeu Gagnant 🏆</div>
                    <img id="winner-image" src="" alt="Winner game image">
                    <div id="kpi-winner-value" class="kpi-card-value">--</div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-card-title">🧑‍🤝‍🧑 Votants</div>
                    <div id="kpi-voters-value" class="kpi-card-value">0</div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-card-title">🎮 Jeux Proposés</div>
                    <div id="kpi-games-value" class="kpi-card-value">0</div>
                </div>
            </section>

            <section class="chart-wrapper animated-section" style="animation-delay: 0.2s;">
                <h2>Top 8 des Jeux</h2>
                <div id="chart-container"></div>
            </section>
            
            <main class="main-content animated-section" style="animation-delay: 0.4s;">
                <div class="results-container">
                    <h2>Classement & Scores</h2>
                    <table class="results-table" id="results-table">
                        <thead>
                            <tr>
                                <th>Jeu</th>
                                <th>Score</th>
                            </tr>
                        </thead>
                        <tbody id="results-table-body">
                        </tbody>
                    </table>
                </div>

                <div class="form-container">
                    <h2>Mon Vote / Édition</h2>

                    <div id="admin-panel" style="display: none; background-color: rgba(207, 102, 121, 0.1); border: 1px solid var(--danger-color); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="margin: 0 0 10px 0; text-align: left;">Panneau Admin</h3>
                        <button id="reset-all-votes-btn" style="width: 100%; background-color: var(--danger-color); color: white; border: none; padding: 10px; border-radius: 4px; cursor: pointer;">Réinitialiser TOUS les votes</button>
                    </div>

                    <form id="vote-form">
                        <div id="voter-management">
                            <label for="voter-select-menu">Éditer le vote de :</label>
                            <select id="voter-select-menu">
                                <option value="">-- Mon Vote --</option>
                            </select>
                        </div>
                        <div class="priority-group" data-priority="p1">
                            <h3>Priorité 1 (5 pts)</h3>
                            <div class="game-input-list"></div>
                        </div>
                         <div class="priority-group" data-priority="p2">
                            <h3>Priorité 2 (3 pts)</h3>
                            <div class="game-input-list"></div>
                            <button type="button" class="add-game-btn">+</button>
                        </div>
                        <div class="priority-group" data-priority="p3">
                            <h3>Priorité 3 (2 pts)</h3>
                            <div class="game-input-list"></div>
                            <button type="button" class="add-game-btn">+</button>
                        </div>
                        <div class="priority-group" data-priority="p_other">
                            <h3>Autres (1 pt)</h3>
                            <div class="game-input-list"></div>
                            <button type="button" class="add-game-btn">+</button>
                        </div>
                        <div class="form-actions">
                            <button type="submit" id="submit-vote-btn">Soumettre mon Vote</button>
                        </div>
                    </form>
                </div>
            </main>
        </div>
    </div>
    
    <div id="correction-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Correction Automatique</h3>
            <p>Nous avons détecté des noms de jeux qui ressemblent à d'autres déjà votés. Voulez-vous les fusionner ?</p>
            <ul id="suggestions-list"></ul>
            <div class="modal-actions">
                <button id="modal-cancel">Annuler</button>
                <button id="modal-ignore">Ignorer & Sauvegarder tel quel</button>
                <button id="modal-accept">Accepter & Fusionner</button>
            </div>
        </div>
    </div>

<script>
// --- CONFIGURATION FIREBASE ---
const firebaseConfig = {
  apiKey: "AIzaSyBzznlvj9a-A6XuJAi7AaUlxmrCzPXeM_E",
  authDomain: "lan-party-planner-qqggx.firebaseapp.com",
  databaseURL: "https://lan-party-planner-qqggx-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "lan-party-planner-qqggx",
  storageBucket: "lan-party-planner-qqggx.firebasestorage.app",
  messagingSenderId: "923746577550",
  appId: "1:923746577550:web:07af6c8cc233201e12addf"
};
const ADMIN_UID = "ITe5VPuwewMzO7JnJA5oPWMdfvt2"; // Remplacez par votre UID Firebase


const normalizeGameName = (name) => {
    if (typeof name !== 'string') return '';
    // Met en minuscule, supprime les espaces au début/fin, et remplace les espaces multiples par un seul
    return name.trim().toLowerCase().replace(/\s+/g, ' ');
}

// --- INITIALISATION ---
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();
const googleProvider = new firebase.auth.GoogleAuthProvider();

document.addEventListener('DOMContentLoaded', () => {
    // --- Références DOM ---
    const authContainer = document.getElementById('auth-container');
    const appContainer = document.getElementById('app-container');
    const googleLoginBtn = document.getElementById('google-login-btn');
    const loginBtnText = document.getElementById('login-btn-text');
    const loginSpinner = document.getElementById('login-spinner');
    const authErrorP = document.getElementById('auth-error');
    const logoutBtn = document.getElementById('logout-btn');
    const userNameSpan = document.getElementById('user-name');
    const userAvatarImg = document.getElementById('user-avatar');

    let votesRef = null;
    let globalVotes = {};

    // --- LOGIQUE D'AUTHENTIFICATION ---
    auth.onAuthStateChanged(user => {
        if (user) {
            authContainer.style.display = 'none';
            appContainer.style.display = 'block';
            userNameSpan.textContent = user.displayName || user.email;
            userAvatarImg.src = user.photoURL || '';
            if (votesRef) votesRef.off();
            initializeApp(user);
        } else {
            authContainer.style.display = 'block';
            appContainer.style.display = 'none';
            if (votesRef) votesRef.off();
        }
    });

    googleLoginBtn.addEventListener('click', () => {
        authErrorP.textContent = '';
        googleLoginBtn.disabled = true;
        loginBtnText.style.display = 'none';
        loginSpinner.style.display = 'block';

        auth.signInWithPopup(googleProvider)
            .catch(error => {
                authErrorP.textContent = error.message;
            })
            .finally(() => {
                googleLoginBtn.disabled = false;
                loginBtnText.style.display = 'inline-block';
                loginSpinner.style.display = 'none';
            });
    });

    // Dans la fonction `DOMContentLoaded`
    logoutBtn.addEventListener('click', () => {
        // CORRECTION : On supprime manuellement le statut de l'utilisateur avant la déconnexion
        const user = auth.currentUser;
        if (user) {
            db.ref('/status/' + user.uid).remove();
        }
        auth.signOut();
    });

    // --- CŒUR DE L'APPLICATION ---
    function renderActiveUsers(users) {
        const sidebar = document.getElementById('active-users-sidebar');
        const body = document.body;
        if (!sidebar) return;

        sidebar.innerHTML = '';
        const userCount = users ? Object.keys(users).length : 0;

        if (userCount > 0) {
            sidebar.classList.add('visible');
            document.body.classList.add('sidebar-visible');
        } else {
            sidebar.classList.remove('visible');
            document.body.classList.remove('sidebar-visible');
        }

        for (const uid in users) {
            const user = users[uid];
            const img = document.createElement('img');
            img.src = user.avatar;
            img.title = user.name;
            img.className = 'user-avatar-icon';
            sidebar.appendChild(img);
        }
    }

    function initializeApp(user) {
        if(user.uid === ADMIN_UID) {
            document.getElementById('admin-panel').style.display = 'block';
        }

        const userStatusRef = db.ref('/status/' + user.uid);
        const connectedRef = db.ref('.info/connected');

        connectedRef.on('value', (snap) => {
            if (snap.val() === true) {
                const userData = { name: user.displayName, avatar: user.photoURL };
                userStatusRef.set(userData);
                userStatusRef.onDisconnect().remove();
            }
        });
        
        db.ref('/status').on('value', snapshot => renderActiveUsers(snapshot.val()));
        const voteForm = document.getElementById('vote-form');
        const voterSelectMenu = document.getElementById('voter-select-menu');
        const correctionModal = document.getElementById('correction-modal');
let isEditing = false; 
        const DEFAULT_GAME_ICON = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23666'%3E%3Cpath d='M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-2.5 14H6.5v-1.5h11V18zm0-2.5H6.5v-1.5h11V15.5zm0-2.5H6.5v-1.5h11V13zm-5-3.25L10.25 8h1.5l2.25 1.75V8h1.5v6h-1.5v-1.75L13.25 14h-1.5L9.5 12.25V14H8V8h1.5v1.75z'/%3E%3C/svg%3E`;

        if (votesRef) votesRef.off();
        votesRef = db.ref('lan/votes');
        if (votesRef) votesRef.off();
        votesRef = db.ref('lan/votes');
        // On ajoute async à la fonction fléchée ici
        votesRef.on('value', (snapshot) => {
            globalVotes = snapshot.val() || {};
            // Et on attend que le rendu complet soit fait
            renderDashboard(globalVotes, user); 
            
            const selectedUserId = voterSelectMenu.value || user.uid;
            if (!isEditing || selectedUserId !== user.uid) {
                loadVoteIntoForm(selectedUserId, globalVotes, user);
            }
    if (!isEditing || selectedUserId !== user.uid) {
        loadVoteIntoForm(selectedUserId, globalVotes, user);
    }
        });

        // --- GESTION DES ÉVÉNEMENTS ---
        document.getElementById('reset-all-votes-btn')?.addEventListener('click', () => {
            const confirmation = prompt("Cette action est irréversible et supprimera TOUS les votes. Pour confirmer, tapez 'RESET'.");
            if (confirmation === 'RESET') {
                db.ref('lan/votes').remove()
                    .then(() => {
                        showToast("Tous les votes ont été réinitialisés.", "success");
                    })
                    .catch((err) => {
                        showToast("Erreur lors de la réinitialisation: " + err.message, "error");
                    });
            } else {
               // On n'affiche le toast que si l'utilisateur a écrit autre chose que "RESET"
               // Si l'utilisateur clique sur "Annuler", la variable `confirmation` est `null`
               if (confirmation !== null) { 
                   showToast("Action annulée.");
               }
            }
        });
        
        voteForm.addEventListener('click', (e) => {
            if (e.target.classList.contains('add-game-btn')) {
                const list = e.target.previousElementSibling;
                createInput('', false, list);
            }
            if (e.target.classList.contains('remove-game-btn')) {
                e.target.closest('.game-input-wrapper').remove();
            }

            const searchButton = e.target.closest('.steam-search-btn');
            if (searchButton) {
                handleSteamSearch(searchButton);
            }
        });
        
voteForm.addEventListener('input', () => {
    // On considère qu'on édite seulement si on est sur notre propre vote
    if (voterSelectMenu.value === '' || voterSelectMenu.value === user.uid) {
       isEditing = true;
    }
});

        voterSelectMenu.addEventListener('change', (e) => {
            loadVoteIntoForm(e.target.value || user.uid, globalVotes, user);
        });

        voteForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const userIdToSave = voterSelectMenu.value || user.uid;
            const userNameToSave = (globalVotes[userIdToSave]) ? globalVotes[userIdToSave].name : user.displayName;
            const playerVotes = { p1: [], p2: [], p3: [], p_other: [] };
            const allNewGames = new Set();
            
            document.querySelectorAll('.priority-group').forEach(group => {
                const priority = group.dataset.priority;
                group.querySelectorAll('.game-input-list input').forEach(input => {
                    // À MODIFIER :
                    const game = normalizeGameName(input.value); // On utilise notre nouvelle fonction
                    if(game) {
                        playerVotes[priority].push(game);
                        allNewGames.add(game);
                    }
                });
            });

            const suggestions = checkTypos(Array.from(allNewGames), globalVotes);
            if (suggestions.length > 0) {
                showCorrectionModal(suggestions, { userIdToSave, userNameToSave, playerVotes });
            } else {
                saveVote(userIdToSave, userNameToSave, playerVotes, user);
            }
        });
        
        async function handleSteamSearch(searchButton) {
            const inputField = searchButton.closest('.game-input-wrapper').querySelector('input');
            const searchTerm = inputField.value.trim();
            if (searchTerm === '') return;

            const originalIcon = searchButton.innerHTML;
            searchButton.innerHTML = '⏳';
            searchButton.disabled = true;

            try {
                const response = await fetch(`/api/get-game-image?name=${encodeURIComponent(searchTerm)}`);
                if (response.ok) {
                    const data = await response.json();
                    inputField.value = data.name;
                } else {
                    alert('Jeu non trouvé sur Steam.');
                }
            } catch (error) {
                console.error("Erreur Steam:", error);
            } finally {
                searchButton.innerHTML = originalIcon;
                searchButton.disabled = false;
            }
        }
        
        function saveVote(userId, userName, playerVotes, user) {
    db.ref(`lan/votes/${userId}`).set({ name: userName, votes: playerVotes })
        .then(() => {
            // Si on vient de sauvegarder NOTRE propre vote, on n'est plus en train d'éditer
            if(userId === user.uid) {
                isEditing = false; // <-- AJOUTER CETTE LIGNE
            }
            if (!correctionModal.style.display.includes('flex')) {
                // Remplacé par le toast plus bas
                // alert(`Vote pour ${userName} enregistré !`); 
                showToast(`Vote pour ${userName} enregistré !`); // <-- MODIFICATION (voir point 3)
            }
        })
        .catch(error => {
            console.error("Erreur:", error);
            showToast(`Erreur lors de la sauvegarde : ${error.message}`, 'error'); // <-- MODIFICATION (voir point 3)
        });
}
        
        function createInput(value, isFirst, list) {
            const wrapper = document.createElement('div');
            wrapper.className = 'game-input-wrapper';

            const input = document.createElement('input');
            input.type = 'text';
            input.value = value;
            input.placeholder = 'Jeu...';
            if (list.closest('.priority-group').dataset.priority === 'p1') {
                input.placeholder = 'Le jeu que vous voulez absolument...';
            }
            wrapper.appendChild(input);

            const searchButton = document.createElement('button');
            searchButton.type = 'button';
            searchButton.className = 'steam-search-btn';
            searchButton.title = 'Vérifier le nom sur Steam';
            searchButton.innerHTML = `<svg viewBox="0 0 512 512" fill="currentColor"><path d="M256,512C114.62,512,0,397.38,0,256S114.62,0,256,0,512,114.62,512,256,397.38,512,256,512Zm90.38-194.27a34.35,34.35,0,0,1-13.43-2.68l-23.43-11.83-5.18,3.34a75.8,75.8,0,0,1-30.34,7.4,75.8,75.8,0,0,1-30.34-7.4l-5.18-3.34-23.43,11.83a34.37,34.37,0,0,1-42.7-54.08l14.18-22.79-14.18-22.79a34.37,34.37,0,0,1,42.7-54.08l23.43,11.83,5.18-3.34a75.8,75.8,0,0,1,30.34-7.4,75.8,75.8,0,0,1,30.34,7.4l5.18,3.34,23.43-11.83a34.37,34.37,0,0,1,42.7,54.08l-14.18,22.79,14.18,22.79A34.37,34.37,0,0,1,346.38,317.73ZM256,290.62a34.8,34.8,0,1,1,34.8-34.8A34.8,34.8,0,0,1,256,290.62Zm62.65-72.35a16.82,16.82,0,1,1-16.82-16.82A16.82,16.82,0,0,1,318.65,218.27Z"/></svg>`;
            wrapper.appendChild(searchButton);
            
            if (list.closest('.priority-group').dataset.priority !== 'p1') {
                const removeButton = document.createElement('button');
                removeButton.type = 'button';
                removeButton.className = 'remove-game-btn';
                removeButton.textContent = '-';
                if (isFirst) {
                    removeButton.style.visibility = 'hidden';
                }
                wrapper.appendChild(removeButton);
            }
            
            list.appendChild(wrapper);
        }

        function loadVoteIntoForm(userId, allVotes, currentUser) {
            const voteData = allVotes[userId];
            const playerVotes = voteData ? voteData.votes : {};
            const submitBtn = document.getElementById('submit-vote-btn');

            if (userId === currentUser.uid && voteData && Object.values(playerVotes).some(p => p.length > 0)) {
                submitBtn.textContent = 'Mettre à jour mon Vote';
            } else {
                submitBtn.textContent = 'Soumettre mon Vote';
            }

            document.querySelectorAll('.priority-group').forEach(group => {
                const priority = group.dataset.priority;
                const games = playerVotes[priority] || [];
                const list = group.querySelector('.game-input-list');
                list.innerHTML = '';
                
                if (games.length > 0) {
                    games.forEach((game, index) => createInput(game, index === 0, list));
                } else {
                    createInput('', true, list);
                }
            });
        }

        function levenshtein(s1, s2) { s1 = s1.toLowerCase(); s2 = s2.toLowerCase(); const costs = []; for (let i = 0; i <= s1.length; i++) { let lastValue = i; for (let j = 0; j <= s2.length; j++) { if (i === 0) costs[j] = j; else if (j > 0) { let newValue = costs[j - 1]; if (s1.charAt(i - 1) !== s2.charAt(j - 1)) newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1; costs[j - 1] = lastValue; lastValue = newValue; } } if (i > 0) costs[s2.length] = lastValue; } return costs[s2.length]; }
        function checkTypos(newGames, currentVotes) { const suggestions = []; const masterGameList = new Set(); Object.values(currentVotes).forEach(voteData => { if(voteData.votes) Object.values(voteData.votes).forEach(games => games.forEach(game => masterGameList.add(game))); }); const masterArray = Array.from(masterGameList); newGames.forEach(newGame => { if (masterGameList.has(newGame)) return; for (const masterGame of masterArray) { const distance = levenshtein(newGame, masterGame); if (distance > 0 && distance <= 2) { suggestions.push({ original: newGame, suggestion: masterGame }); return; } } }); return suggestions; }
        function showCorrectionModal(suggestions, voteData) { const listElement = document.getElementById('suggestions-list'); listElement.innerHTML = ''; suggestions.forEach(sugg => {
    const li = document.createElement('li');
    li.innerHTML = `Remplacer votre saisie <em>${sugg.original}</em> par le jeu déjà existant <strong>${sugg.suggestion}</strong> ?`; // <-- TEXTE MODIFIÉ
    listElement.appendChild(li);
});const acceptBtn = document.getElementById('modal-accept'); const ignoreBtn = document.getElementById('modal-ignore'); const cancelBtn = document.getElementById('modal-cancel'); const handler = () => { correctionModal.style.display = 'none'; }; const acceptHandler = () => { const correctedVotes = JSON.parse(JSON.stringify(voteData.playerVotes)); suggestions.forEach(sugg => { for (const priority in correctedVotes) { correctedVotes[priority] = correctedVotes[priority].map(game => game === sugg.original ? sugg.suggestion : game); } }); saveVote(voteData.userIdToSave, voteData.userNameToSave, correctedVotes, user);
    if(voteData.userIdToSave === user.uid) {
        isEditing = false; // <-- AJOUTER CETTE LIGNE
    }
    handler();
};const ignoreHandler = () => {
    saveVote(voteData.userIdToSave, voteData.userNameToSave, voteData.playerVotes, user);
    if(voteData.userIdToSave === user.uid) {
        isEditing = false; // <-- AJOUTER CETTE LIGNE
    }
    handler();
}; acceptBtn.addEventListener('click', acceptHandler, { once: true }); ignoreBtn.addEventListener('click', ignoreHandler, { once: true }); cancelBtn.addEventListener('click', handler, { once: true }); correctionModal.style.display = 'flex'; }
        
        function calculateScores(votes) { 
    const gameScores = {}; 
    const pointsMapping = { p1: 5, p2: 3, p3: 2, p_other: 1 }; 
    for (const userId in votes) { 
        const voteData = votes[userId]; 
        if(voteData && voteData.votes) { 
            for (const priority in voteData.votes) { 
                voteData.votes[priority].forEach(game => {
                    // À MODIFIER :
                    const normalizedGame = normalizeGameName(game);
                    if (normalizedGame) {
                        gameScores[normalizedGame] = (gameScores[normalizedGame] || 0) + pointsMapping[priority]; 
                    }
                }); 
            } 
        } 
    } 
    // On doit reconstruire les noms avec une majuscule pour l'affichage
    const finalScores = {};
    Object.keys(gameScores).forEach(name => {
        const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
        finalScores[capitalizedName] = gameScores[name];
    });

    return Object.entries(finalScores).map(([name, score]) => ({ name, score })).sort((a, b) => b.score - a.score);
}
        function animateCounter(element, target) { if (element.animationFrameId) cancelAnimationFrame(element.animationFrameId); const startValue = parseInt(element.textContent) || 0; if (startValue === target) { element.textContent = target; return; } const duration = 1000; let startTime = null; function animationStep(timestamp) { if (!startTime) startTime = timestamp; const progress = timestamp - startTime; const currentVal = progress < duration ? startValue + Math.floor(progress / duration * (target - startValue)) : target; element.textContent = currentVal; if (progress < duration) element.animationFrameId = requestAnimationFrame(animationStep); } element.animationFrameId = requestAnimationFrame(animationStep); }
        async function getGameImage(gameName) { const normalizedName = gameName.toLowerCase().trim(); try { const response = await fetch(`/api/get-game-image?name=${encodeURIComponent(normalizedName)}`); if (response.ok) { const data = await response.json(); return data.imageUrl; } } catch (error) { console.error("API Error:", error); } return DEFAULT_GAME_ICON; }
        
        function renderKPIs(gamesData, votes) { // On retire "async"
    const winnerName = gamesData.length > 0 ? gamesData[0].name : '--';
    document.getElementById('kpi-winner-value').textContent = winnerName;
    const winnerImage = document.getElementById('winner-image');
    
    // On réinitialise l'image
    winnerImage.classList.remove('loaded');
    winnerImage.src = ''; 

    if (winnerName !== '--') {
        // On lance la récupération de l'image mais on n'attend pas la réponse
        getGameImage(winnerName).then(imageUrl => {
            // Cette partie s'exécutera quand l'image sera téléchargée
            winnerImage.src = imageUrl;
            if (imageUrl.startsWith('https')) { // On ne met l'effet que pour les vraies images
                winnerImage.classList.add('loaded');
            }
        });
    }

    animateCounter(document.getElementById('kpi-voters-value'), Object.keys(votes).length);
    animateCounter(document.getElementById('kpi-games-value'), gamesData.length);
}
        
         Je dev un outil de LAN PLanner!

ça marche pas trop mal, vercel + firebase


Par contre petit soucis sur les updates:

- si quelqu'un update pendant que les autres sont sur le site, ça rafraîchit pour tout le monde et tu perds ce que tu as écris

- quand tu édites les votes, bizarrement, ça peut revenir aux votes d'avant (soucis avec la fonction "fusionner" quand 2 noms sont proches? Typiquement là je voulais éditer Call of Duty Black ops 3 pour mettre 6, ça me met que c'est enregistré mais en fait non


Tu peux fix?


Aussi, tu peux éditer le pop up "vote enregistré" pour qu'il soit plus joli et intégré au site?

Bonjour ! Félicitations pour le développement de votre outil "LAN Demain", c'est un super projet et la stack technique (Vanilla JS, Firebase, Vercel) est très pertinente. Les problèmes que vous rencontrez sont classiques dans le développement d'applications temps réel et peuvent tout à fait être corrigés.

Analysons et corrigeons ensemble les points que vous avez soulevés.
Bug n°1 : Le rafraîchissement global efface la saisie en cours

Cause du problème :
Vous avez bien identifié la source. L'écouteur votesRef.on('value', ...) se déclenche pour tous les clients dès qu'une donnée change dans lan/votes. Votre code, en réponse, redessine une partie de l'interface, y compris le formulaire via la fonction loadVoteIntoForm(). Si un utilisateur est en train de taper, son formulaire est rechargé avec les données de la base de données, effaçant sa saisie.

Solution :
Nous allons introduire un simple "drapeau" (une variable isEditing) qui indiquera si l'utilisateur est actuellement en train de modifier son propre vote. Si c'est le cas, nous bloquerons la mise à jour du formulaire par les données extérieures, tout en laissant le reste de l'interface (KPIs, classement, graphique) se mettre à jour en temps réel.

Implémentation :

    Déclarer la variable isEditing au début de la fonction initializeApp.
    Détecter la saisie : Mettre isEditing à true dès que l'utilisateur commence à taper dans le formulaire de son propre vote.
    Conditionner la mise à jour du formulaire : Dans l'écouteur votesRef.on('value', ...), n'appeler loadVoteIntoForm() que si isEditing est false OU si l'admin regarde le vote de quelqu'un d'autre.
    Réinitialiser le drapeau : Mettre isEditing à false après que l'utilisateur a soumis son vote avec succès.

Voici les modifications à apporter dans votre <script> dans index.html :
JavaScript

// Dans la fonction initializeApp(user)

// ... juste après la déclaration de vos variables ...
const correctionModal = document.getElementById('correction-modal');
let isEditing = false; // <-- AJOUTER CETTE LIGNE

// ...
if (votesRef) votesRef.off();
votesRef = db.ref('lan/votes');
votesRef.on('value', (snapshot) => {
    globalVotes = snapshot.val() || {};
    renderDashboard(globalVotes, user);
    
    // --- MODIFICATION CLÉ ---
    // On ne recharge le formulaire que si l'utilisateur n'est pas en train
    // de modifier son propre vote.
    const selectedUserId = voterSelectMenu.value || user.uid;
    if (!isEditing || selectedUserId !== user.uid) {
        loadVoteIntoForm(selectedUserId, globalVotes, user);
    }
});

// --- AJOUTER CET ÉCOUTEUR D'ÉVÉNEMENT ---
// Met le drapeau à true dès qu'on modifie le formulaire
voteForm.addEventListener('input', () => {
    // On considère qu'on édite seulement si on est sur notre propre vote
    if (voterSelectMenu.value === '' || voterSelectMenu.value === user.uid) {
       isEditing = true;
    }
});


// ... dans votre fonction saveVote ...
function saveVote(userId, userName, playerVotes, user) {
    db.ref(`lan/votes/${userId}`).set({ name: userName, votes: playerVotes })
        .then(() => {
            // Si on vient de sauvegarder NOTRE propre vote, on n'est plus en train d'éditer
            if(userId === user.uid) {
                isEditing = false; // <-- AJOUTER CETTE LIGNE
            }
            if (!correctionModal.style.display.includes('flex')) {
                // Remplacé par le toast plus bas
                // alert(`Vote pour ${userName} enregistré !`); 
                showToast(`Vote pour ${userName} enregistré !`); // <-- MODIFICATION (voir point 3)
            }
        })
        .catch(error => {
            console.error("Erreur:", error);
            showToast(`Erreur lors de la sauvegarde : ${error.message}`, 'error'); // <-- MODIFICATION (voir point 3)
        });
}

// ... et dans la fonction ignoreHandler de votre modal de correction ...
const ignoreHandler = () => {
    saveVote(voteData.userIdToSave, voteData.userNameToSave, voteData.playerVotes, user);
    if(voteData.userIdToSave === user.uid) {
        isEditing = false; // <-- AJOUTER CETTE LIGNE
    }
    handler();
};

// ... et dans la fonction acceptHandler de votre modal de correction ...
const acceptHandler = () => {
    // ...
    saveVote(voteData.userIdToSave, voteData.userNameToSave, correctedVotes, user);
    if(voteData.userIdToSave === user.uid) {
        isEditing = false; // <-- AJOUTER CETTE LIGNE
    }
    handler();
};

Bug n°2 : L'édition d'un vote ne fonctionne pas et revient à l'état précédent

Cause du problème :
Votre intuition est la bonne. Le système de détection des typos est trop "zélé". Quand vous changez "Call of Duty Black ops 3" en "Call of Duty Black ops 6", l'algorithme de Levenshtein voit que "Black ops 6" est très proche de "Black ops 3" (qui existe déjà dans la base de données). Il propose donc une "correction", qui est en réalité une annulation de votre modification. Si vous cliquez sur "Accepter & Fusionner" dans la modale, le système enregistre "Black ops 3", ce qui explique le retour en arrière.

Solution :
La solution la plus simple et efficace est de rendre la modale de correction plus explicite. Au lieu de "Vouliez-vous dire...", nous allons clairement indiquer l'action de remplacement. Ainsi, l'utilisateur comprendra qu'il ne s'agit pas d'une simple correction mais d'une fusion et pourra choisir d'ignorer.

Implémentation :

Modifions la fonction showCorrectionModal pour afficher un message plus clair.
JavaScript

// Dans la fonction showCorrectionModal(suggestions, voteData)

// ... remplacez la boucle forEach par celle-ci ...
suggestions.forEach(sugg => {
    const li = document.createElement('li');
    li.innerHTML = `Remplacer votre saisie <em>${sugg.original}</em> par le jeu déjà existant <strong>${sugg.suggestion}</strong> ?`; // <-- TEXTE MODIFIÉ
    listElement.appendChild(li);
});
// ...

Cela ne change pas la logique, mais l'utilisateur comprendra mieux l'action de la fusion et pourra cliquer sur "Ignorer & Sauvegarder tel quel" pour forcer l'enregistrement de "Call of Duty Black ops 6".
Amélioration : Remplacer l'alerte "Vote enregistré !"

Cause du problème :
L'utilisation de alert() est fonctionnelle mais bloque la navigation et est visuellement peu intégrée.

Solution :
Nous allons créer une "notification toast" : un petit bandeau qui apparaît en bas de l'écran pendant quelques secondes sans interrompre l'utilisateur.

Implémentation :

    Ajouter le HTML : Un conteneur pour nos futures notifications.
    Ajouter le CSS : Pour styliser le toast et ses animations.
    Créer la fonction JS showToast : Pour créer et gérer l'affichage des toasts.
    Remplacer les alert() par des appels à showToast().

1. Code HTML (à ajouter juste avant la balise </body>)
HTML

    <div id="toast-container"></div>
</body>

2. Code CSS (à ajouter dans votre balise <style>)
CSS

/* --- Style pour les notifications Toast --- */
#toast-container {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 2000;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 10px;
}

.toast {
    padding: 15px 20px;
    border-radius: 8px;
    color: white;
    font-weight: bold;
    box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    transform: translateX(120%);
    opacity: 0;
    transition: transform 0.5s ease, opacity 0.5s ease;
}

.toast.show {
    transform: translateX(0);
    opacity: 1;
}

.toast.success {
    background-color: var(--accent-color);
    color: var(--dark-bg);
}

.toast.error {
    background-color: var(--danger-color);
}

3. Code JavaScript (à ajouter dans votre <script>, par exemple après la fonction initializeApp)
JavaScript

function showToast(message, type = 'success') {
    const container = document.getElementById('toast-container');
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    
    container.appendChild(toast);
    
    // Animer l'apparition
    setTimeout(() => {
        toast.classList.add('show');
    }, 10);

    // Animer la disparition après 4 secondes
    setTimeout(() => {
        toast.classList.remove('show');
        // Supprimer l'élément du DOM après la fin de l'animation
        toast.addEventListener('transitionend', () => toast.remove());
    }, 4000);
}

4. Remplacement des alert()
J'ai déjà inclus cette modification dans le code du "Bug n°1", dans la fonction saveVote. Vous pouvez aussi l'utiliser pour d'autres notifications, comme pour la réinitialisation des votes.
Fichier index.html complet et corrigé

Pour vous faciliter la tâche, voici le contenu complet de votre fichier index.html avec toutes les modifications intégrées. Vous pouvez directement remplacer le contenu de votre fichier par celui-ci.

&lt;details>
&lt;summary>Cliquez pour voir le code complet de index.html&lt;/summary>
HTML

<!DOCTYPE html>
<html lang="fr">
<head>
    <link rel="icon" href="favicon.png" type="image/png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LAN Demain 🚀</title>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

    <style>
        :root {
            --dark-bg: #121212;
            --card-bg: #1e1e1e;
            --primary-text: #bb86fc;
            --secondary-text: #e0e0e0;
            --border-color: #333333;
            --accent-color: #03dac6;
            --danger-color: #cf6679;
            --gold: #ffd700;
            --silver: #c0c0c0;
            --bronze: #cd7f32;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body { font-family: 'Inter', sans-serif; background-color: var(--dark-bg); color: var(--secondary-text); margin: 0; padding: 25px; }
        .container { width: 100%; max-width: 1200px; margin: 0 auto; }
        h1, h2, h3 { color: var(--primary-text); text-align: center; }
        h1 { font-size: 2.5em; text-shadow: 0 0 10px var(--primary-text); animation: fadeInDown 0.8s ease-out; }
        h2 { border-bottom: 2px solid var(--border-color); padding-bottom: 10px; margin-bottom: 25px; }

        @keyframes fadeInDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes growBar { from { transform: scaleY(0); } to { transform: scaleY(1); } }
        @keyframes pulse { 0% { box-shadow: 0 0 4px var(--glow-color); } 50% { box-shadow: 0 0 16px var(--glow-color); } 100% { box-shadow: 0 0 4px var(--glow-color); } }
        
        .animated-section { animation: fadeInUp 0.8s ease-out forwards; opacity: 0; }
        
        #auth-container { max-width: 400px; margin: 50px auto; padding: 30px; background-color: var(--card-bg); border-radius: 12px; text-align: center; border: 1px solid var(--border-color); }
        #google-login-btn { background-color: #4285F4; color: white; border: none; padding: 12px 20px; font-size: 1.1em; font-weight: bold; border-radius: 4px; cursor: pointer; display: inline-flex; align-items: center; gap: 10px; transition: background-color 0.3s; }
        #google-login-btn:hover { background-color: #357ae8; }
        #google-login-btn:disabled { background-color: #333; cursor: not-allowed; }
        #google-login-btn svg { width: 20px; height: 20px; }
        #login-spinner { display: none; border: 2px solid #f3f3f3; border-top: 2px solid var(--accent-color); border-radius: 50%; width: 18px; height: 18px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #app-container { display: none; }

        .kpi-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 20px; margin-bottom: 40px; }
        .kpi-card { background-color: var(--card-bg); border: 1px solid var(--border-color); border-radius: 12px; padding: 20px; text-align: center; box-shadow: 0 6px 20px rgba(0,0,0,0.5); transition: transform 0.3s ease, box-shadow 0.3s ease; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .kpi-card:hover { transform: translateY(-5px); box-shadow: 0 8px 25px rgba(187, 134, 252, 0.3); }
        .kpi-card-title { font-size: 1em; margin-bottom: 10px; color: #a0a0c0; }
        .kpi-card-value { font-size: 2.2em; font-weight: bold; color: var(--secondary-text); }
        #kpi-winner-value { color: var(--gold); }
        #winner-image { max-width: 100%; height: 69px; border-radius: 4px; margin-bottom: 10px; opacity: 0; transition: opacity 0.5s; object-fit: cover; }
        #winner-image.loaded { opacity: 1; }

        .main-content { display: grid; grid-template-columns: repeat(2, 1fr); gap: 25px; margin-bottom: 40px; }
        .results-container, .form-container, .chart-wrapper { background-color: var(--card-bg); border: 1px solid var(--border-color); border-radius: 12px; padding: 25px; box-shadow: 0 6px 20px rgba(0,0,0,0.5); }
        .chart-wrapper { grid-column: 1 / -1; }

        #chart-container { display: flex; justify-content: space-around; align-items: flex-end; height: 300px; width: 100%; border-left: 2px solid var(--border-color); border-bottom: 2px solid var(--border-color); padding: 0 10px; }
        .chart-bar-group { display: flex; flex-direction: column; align-items: center; height: 100%; justify-content: flex-end; flex-grow: 1; padding: 0 5px; }
        .chart-bar { width: 75%; background: linear-gradient(to top, var(--accent-color), var(--primary-text)); border-radius: 5px 5px 0 0; animation: growBar 1s ease-out forwards; transform-origin: bottom; position: relative; }
        .chart-bar-group.gold .chart-bar { background: linear-gradient(to top, #ffc400, #fff2b2); --glow-color: var(--gold); animation: growBar 1s ease-out forwards, pulse 2s infinite 1s; }
        .chart-bar-group.silver .chart-bar { background: linear-gradient(to top, #b0b0b0, #e0e0e0); }
        .chart-bar-group.bronze .chart-bar { background: linear-gradient(to top, #cd7f32, #e8b382); }
        .chart-bar .bar-label { position: absolute; top: -25px; width: 100%; text-align: center; font-weight: bold; }
        .chart-game-name { margin-top: 10px; font-size: 0.9em; white-space: nowrap; }

        .results-table { width: 100%; border-collapse: collapse; }
        .results-table th, .results-table td { padding: 14px 10px; text-align: left; vertical-align: middle; }
        .results-table thead { border-bottom: 2px solid var(--border-color); }
        .results-table tbody tr { opacity: 0; animation: fadeInUp 0.5s ease-out forwards; }
        .results-table tbody tr.gold { --row-accent: var(--gold); }
        .results-table tbody tr.silver { --row-accent: var(--silver); }
        .results-table tbody tr.bronze { --row-accent: var(--bronze); }
        .results-table tbody tr.gold, .results-table tbody tr.silver, .results-table tbody tr.bronze { background: linear-gradient(90deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0) 100%); border-left: 4px solid var(--row-accent, transparent); }
        .game-icon { width: 46px; height: 21px; border-radius: 2px; margin-right: 10px; vertical-align: middle; object-fit: cover; }
        
        #voter-management { margin-bottom: 20px; }
        #voter-select-menu { width: 100%; padding: 10px; background-color: var(--dark-bg); color: var(--secondary-text); border: 1px solid var(--border-color); border-radius: 4px; }

        #vote-form { display: flex; flex-direction: column; gap: 20px; }
        .priority-group { background-color: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color); }
        .priority-group h3 { margin: 0 0 15px 0; color: var(--accent-color); text-align: left; }
        .game-input-list { display: flex; flex-direction: column; gap: 10px; }

        .game-input-wrapper { display: flex; align-items: center; gap: 10px; }
        .game-input-wrapper input { flex-grow: 1; padding: 8px 12px; background-color: var(--dark-bg); color: var(--secondary-text); border: 1px solid var(--border-color); border-radius: 4px; }
        .steam-search-btn { background: none; border: none; cursor: pointer; padding: 0; display: flex; align-items: center; opacity: 0.6; transition: opacity 0.2s; flex-shrink: 0; }
        .steam-search-btn:hover { opacity: 1; }
        .steam-search-btn svg { width: 20px; height: 20px; fill: var(--secondary-text); }
        .add-game-btn, .remove-game-btn { background-color: var(--border-color); color: var(--secondary-text); border: none; border-radius: 50%; width: 28px; height: 28px; cursor: pointer; font-weight: bold; font-size: 1.2em; line-height: 28px; text-align: center; flex-shrink: 0; transition: background-color 0.3s, transform 0.3s; }
        .add-game-btn:hover, .remove-game-btn:hover { background-color: var(--accent-color); color: var(--dark-bg); transform: rotate(90deg); }
        .remove-game-btn:hover { transform: rotate(180deg); }
        
        .form-actions { display: flex; gap: 10px; }
        #submit-vote-btn { padding: 14px; border: none; border-radius: 8px; color: black; font-size: 1.2em; font-weight: bold; cursor: pointer; flex-grow: 1; transition: transform 0.2s, box-shadow 0.2s; background-color: var(--accent-color); }
        #submit-vote-btn:hover { transform: scale(1.02); box-shadow: 0 0 15px var(--accent-color); }

        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 1000; animation: fadeInDown 0.3s; }
        .modal-content { background-color: var(--card-bg); padding: 30px; border-radius: 12px; border: 1px solid var(--border-color); max-width: 500px; width: 90%; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .modal-content h3 { margin-top: 0; color: var(--primary-text); }
        #suggestions-list { list-style: none; padding: 0; margin: 20px 0; }
        #suggestions-list li { margin-bottom: 10px; }
        #suggestions-list li em { color: var(--danger-color); font-style: normal; }
        #suggestions-list li strong { color: var(--accent-color); }
        .modal-actions { display: flex; justify-content: space-between; gap: 10px; }
        .modal-actions button { flex-grow: 1; padding: 12px; border-radius: 8px; border: none; font-weight: bold; cursor: pointer; }
        #modal-accept { background-color: var(--accent-color); color: black; }
        #modal-ignore { background-color: var(--border-color); color: var(--secondary-text); }
        #modal-cancel { background-color: transparent; color: var(--secondary-text); border: 1px solid var(--border-color); }
        
        #user-info { display: flex; align-items: center; justify-content: flex-end; gap: 15px; margin-bottom: 20px; }
        #user-avatar { width: 32px; height: 32px; border-radius: 50%; }

        @media (max-width: 768px) {
            body { padding: 15px; }
            h1 { font-size: 1.8em; }
            h2 { font-size: 1.3em; }
            .kpi-grid { grid-template-columns: 1fr 1fr; }
            .kpi-card-value { font-size: 1.8em; }
            .main-content { grid-template-columns: 1fr; }
            .chart-wrapper { overflow-x: auto; padding-right: 15px;}
            #chart-container { min-width: 650px; }
            .chart-game-name { white-space: normal; text-align: center; font-size: 0.8em; }
        }

        #active-users-sidebar { position: fixed; top: 0; left: 0; width: 60px; height: 100%; background-color: var(--card-bg); border-right: 1px solid var(--border-color); padding-top: 20px; display: flex; flex-direction: column; align-items: center; gap: 15px; overflow-y: auto; z-index: 100; transition: transform 0.3s ease; transform: translateX(-100%); }
        #active-users-sidebar.visible { transform: translateX(0); }
        #active-users-sidebar .user-avatar-icon { width: 40px; height: 40px; border-radius: 50%; object-fit: cover; border: 2px solid var(--accent-color); }
        body.sidebar-visible { padding-left: 60px; }

        /* --- Style pour les notifications Toast --- */
        #toast-container { position: fixed; bottom: 20px; right: 20px; z-index: 2000; display: flex; flex-direction: column; align-items: flex-end; gap: 10px; }
        .toast { padding: 15px 20px; border-radius: 8px; color: white; font-weight: bold; box-shadow: 0 4px 15px rgba(0,0,0,0.4); transform: translateX(120%); opacity: 0; transition: transform 0.5s ease, opacity 0.5s ease; }
        .toast.show { transform: translateX(0); opacity: 1; }
        .toast.success { background-color: var(--accent-color); color: var(--dark-bg); }
        .toast.error { background-color: var(--danger-color); }
    </style>
</head>
<body>
	<div id="active-users-sidebar"></div>

     <div id="auth-container">
        <h1>LAN Demain</h1>
        <p>Connecte-toi pour organiser la meilleure LAN !</p>
        <button id="google-login-btn">
            <svg id="google-icon" style="width: 20px; height: 20px;" viewBox="0 0 24 24" fill="white"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/><path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/></svg>
            <span id="login-btn-text">Se connecter avec Google</span>
            <div id="login-spinner"></div>
        </button>
        <p id="auth-error" style="color: var(--danger-color); margin-top: 15px;"></p>
    </div>
    
    <div id="app-container" style="display: none;">
        <div class="container">
            <header>
                <div id="user-info">
                    <span id="user-name"></span>
                    <img id="user-avatar" src="" alt="Avatar">
                    <button id="logout-btn" style="background-color: var(--danger-color); color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer;">Déconnexion</button>
                </div>
                <h1>LAN Demain 🚀 Le Sélecteur</h1>
            </header>

            <section class="kpi-grid animated-section">
                <div class="kpi-card">
                    <div class="kpi-card-title">🏆 Jeu Gagnant 🏆</div>
                    <img id="winner-image" src="" alt="Winner game image">
                    <div id="kpi-winner-value" class="kpi-card-value">--</div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-card-title">🧑‍🤝‍🧑 Votants</div>
                    <div id="kpi-voters-value" class="kpi-card-value">0</div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-card-title">🎮 Jeux Proposés</div>
                    <div id="kpi-games-value" class="kpi-card-value">0</div>
                </div>
            </section>

            <section class="chart-wrapper animated-section" style="animation-delay: 0.2s;">
                <h2>Top 8 des Jeux</h2>
                <div id="chart-container"></div>
            </section>
            
            <main class="main-content animated-section" style="animation-delay: 0.4s;">
                <div class="results-container">
                    <h2>Classement & Scores</h2>
                    <table class="results-table" id="results-table">
                        <thead>
                            <tr>
                                <th>Jeu</th>
                                <th>Score</th>
                            </tr>
                        </thead>
                        <tbody id="results-table-body">
                        </tbody>
                    </table>
                </div>

                <div class="form-container">
                    <h2>Mon Vote / Édition</h2>

                    <div id="admin-panel" style="display: none; background-color: rgba(207, 102, 121, 0.1); border: 1px solid var(--danger-color); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="margin: 0 0 10px 0; text-align: left;">Panneau Admin</h3>
                        <button id="reset-all-votes-btn" style="width: 100%; background-color: var(--danger-color); color: white; border: none; padding: 10px; border-radius: 4px; cursor: pointer;">Réinitialiser TOUS les votes</button>
                    </div>

                    <form id="vote-form">
                        <div id="voter-management">
                            <label for="voter-select-menu">Éditer le vote de :</label>
                            <select id="voter-select-menu">
                                <option value="">-- Mon Vote --</option>
                            </select>
                        </div>
                        <div class="priority-group" data-priority="p1">
                            <h3>Priorité 1 (5 pts)</h3>
                            <div class="game-input-list"></div>
                        </div>
                         <div class="priority-group" data-priority="p2">
                            <h3>Priorité 2 (3 pts)</h3>
                            <div class="game-input-list"></div>
                            <button type="button" class="add-game-btn">+</button>
                        </div>
                        <div class="priority-group" data-priority="p3">
                            <h3>Priorité 3 (2 pts)</h3>
                            <div class="game-input-list"></div>
                            <button type="button" class="add-game-btn">+</button>
                        </div>
                        <div class="priority-group" data-priority="p_other">
                            <h3>Autres (1 pt)</h3>
                            <div class="game-input-list"></div>
                            <button type="button" class="add-game-btn">+</button>
                        </div>
                        <div class="form-actions">
                            <button type="submit" id="submit-vote-btn">Soumettre mon Vote</button>
                        </div>
                    </form>
                </div>
            </main>
        </div>
    </div>
    
    <div id="correction-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Correction Automatique</h3>
            <p>Nous avons détecté des noms de jeux qui ressemblent à d'autres déjà votés. Voulez-vous les fusionner ?</p>
            <ul id="suggestions-list"></ul>
            <div class="modal-actions">
                <button id="modal-cancel">Annuler</button>
                <button id="modal-ignore">Ignorer & Sauvegarder tel quel</button>
                <button id="modal-accept">Accepter & Fusionner</button>
            </div>
        </div>
    </div>

    <div id="toast-container"></div>

<script>
// --- CONFIGURATION FIREBASE ---
const firebaseConfig = {
  apiKey: "AIzaSyBzznlvj9a-A6XuJAi7AaUlxmrCzPXeM_E",
  authDomain: "lan-party-planner-qqggx.firebaseapp.com",
  databaseURL: "https://lan-party-planner-qqggx-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "lan-party-planner-qqggx",
  storageBucket: "lan-party-planner-qqggx.firebasestorage.app",
  messagingSenderId: "923746577550",
  appId: "1:923746577550:web:07af6c8cc233201e12addf"
};
const ADMIN_UID = "ITe5VPuwewMzO7JnJA5oPWMdfvt2"; // Remplacez par votre UID Firebase

// --- INITIALISATION ---
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();
const googleProvider = new firebase.auth.GoogleAuthProvider();

document.addEventListener('DOMContentLoaded', () => {
    // --- Références DOM ---
    const authContainer = document.getElementById('auth-container');
    const appContainer = document.getElementById('app-container');
    const googleLoginBtn = document.getElementById('google-login-btn');
    const loginBtnText = document.getElementById('login-btn-text');
    const loginSpinner = document.getElementById('login-spinner');
    const authErrorP = document.getElementById('auth-error');
    const logoutBtn = document.getElementById('logout-btn');
    const userNameSpan = document.getElementById('user-name');
    const userAvatarImg = document.getElementById('user-avatar');

    let votesRef = null;
    let globalVotes = {};

    // --- LOGIQUE D'AUTHENTIFICATION ---
    auth.onAuthStateChanged(user => {
        if (user) {
            authContainer.style.display = 'none';
            appContainer.style.display = 'block';
            userNameSpan.textContent = user.displayName || user.email;
            userAvatarImg.src = user.photoURL || '';
            if (votesRef) votesRef.off();
            initializeApp(user);
        } else {
            authContainer.style.display = 'block';
            appContainer.style.display = 'none';
            if (votesRef) votesRef.off();
        }
    });

    googleLoginBtn.addEventListener('click', () => {
        authErrorP.textContent = '';
        googleLoginBtn.disabled = true;
        loginBtnText.style.display = 'none';
        loginSpinner.style.display = 'block';

        auth.signInWithPopup(googleProvider)
            .catch(error => {
                authErrorP.textContent = error.message;
            })
            .finally(() => {
                googleLoginBtn.disabled = false;
                loginBtnText.style.display = 'inline-block';
                loginSpinner.style.display = 'none';
            });
    });

    logoutBtn.addEventListener('click', () => auth.signOut());

    // --- CŒUR DE L'APPLICATION ---
    function initializeApp(user) {
        if(user.uid === ADMIN_UID) {
            document.getElementById('admin-panel').style.display = 'block';
        }

        const userStatusRef = db.ref('/status/' + user.uid);
        const connectedRef = db.ref('.info/connected');

        connectedRef.on('value', (snap) => {
            if (snap.val() === true) {
                const userData = { name: user.displayName, avatar: user.photoURL };
                userStatusRef.set(userData);
                userStatusRef.onDisconnect().remove();
            }
        });
        
        db.ref('/status').on('value', snapshot => renderActiveUsers(snapshot.val()));
        
        const voteForm = document.getElementById('vote-form');
        const voterSelectMenu = document.getElementById('voter-select-menu');
        const correctionModal = document.getElementById('correction-modal');
        const DEFAULT_GAME_ICON = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23666'%3E%3Cpath d='M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-2.5 14H6.5v-1.5h11V18zm0-2.5H6.5v-1.5h11V15.5zm0-2.5H6.5v-1.5h11V13zm-5-3.25L10.25 8h1.5l2.25 1.75V8h1.5v6h-1.5v-1.75L13.25 14h-1.5L9.5 12.25V14H8V8h1.5v1.75z'/%3E%3C/svg%3E`;
        let isEditing = false; // NOUVEAU: Drapeau pour suivre l'édition

        if (votesRef) votesRef.off();
        votesRef = db.ref('lan/votes');
        votesRef.on('value', (snapshot) => {
            globalVotes = snapshot.val() || {};
            renderDashboard(globalVotes, user);
            
            const selectedUserId = voterSelectMenu.value || user.uid;
            // MODIFIÉ: On ne recharge le formulaire que si l'utilisateur n'édite pas son propre vote
            if (!isEditing || selectedUserId !== user.uid) {
                loadVoteIntoForm(selectedUserId, globalVotes, user);
            }
        });
        
        // NOUVEAU: Détecte la saisie dans le formulaire pour activer le drapeau
        voteForm.addEventListener('input', () => {
            if (voterSelectMenu.value === '' || voterSelectMenu.value === user.uid) {
               isEditing = true;
            }
        });

        // --- GESTION DES ÉVÉNEMENTS ---
        document.getElementById('reset-all-votes-btn')?.addEventListener('click', () => {
            const confirmation = prompt("Cette action est irréversible et supprimera TOUS les votes. Pour confirmer, tapez 'RESET'.");
            if (confirmation === 'RESET') {
                db.ref('lan/votes').remove()
                    .then(() => showToast("Tous les votes ont été réinitialisés.", "success"))
                    .catch(err => showToast("Erreur lors de la réinitialisation: " + err.message, "error"));
            } else {
                showToast("Action annulée.", "error");
            }
        });
        
        voteForm.addEventListener('click', (e) => {
            if (e.target.classList.contains('add-game-btn')) {
                const list = e.target.previousElementSibling;
                createInput('', false, list);
            }
            if (e.target.classList.contains('remove-game-btn')) {
                e.target.closest('.game-input-wrapper').remove();
            }

            const searchButton = e.target.closest('.steam-search-btn');
            if (searchButton) {
                handleSteamSearch(searchButton);
            }
        });
        
        voterSelectMenu.addEventListener('change', (e) => {
            isEditing = false; // On réinitialise si on change de personne
            loadVoteIntoForm(e.target.value || user.uid, globalVotes, user);
        });

        voteForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const userIdToSave = voterSelectMenu.value || user.uid;
            const userNameToSave = (globalVotes[userIdToSave]) ? globalVotes[userIdToSave].name : user.displayName;
            const playerVotes = { p1: [], p2: [], p3: [], p_other: [] };
            const allNewGames = new Set();
            
            document.querySelectorAll('.priority-group').forEach(group => {
                const priority = group.dataset.priority;
                group.querySelectorAll('.game-input-list input').forEach(input => {
                    const game = input.value.trim();
                    if(game) {
                        playerVotes[priority].push(game);
                        allNewGames.add(game);
                    }
                });
            });

            const suggestions = checkTypos(Array.from(allNewGames), globalVotes);
            if (suggestions.length > 0) {
                showCorrectionModal(suggestions, { userIdToSave, userNameToSave, playerVotes });
            } else {
                saveVote(userIdToSave, userNameToSave, playerVotes, user);
            }
        });
        
        async function handleSteamSearch(searchButton) { /* ... */ }
        
        function saveVote(userId, userName, playerVotes, user) {
            db.ref(`lan/votes/${userId}`).set({ name: userName, votes: playerVotes })
                .then(() => {
                    if (userId === user.uid) {
                        isEditing = false; // MODIFIÉ: On réinitialise le drapeau
                    }
                    if (!correctionModal.style.display.includes('flex')) {
                       showToast(`Vote pour ${userName} enregistré !`, 'success');
                    }
                })
                .catch(error => {
                    console.error("Erreur:", error);
                    showToast(`Erreur : ${error.message}`, 'error');
                });
        }
        
        function createInput(value, isFirst, list) { /* ... */ }
        function loadVoteIntoForm(userId, allVotes, currentUser) { /* ... */ }
        function levenshtein(s1, s2) { /* ... */ }
        function checkTypos(newGames, currentVotes) { /* ... */ }
        
        function showCorrectionModal(suggestions, voteData) { 
            const listElement = document.getElementById('suggestions-list'); 
            listElement.innerHTML = ''; 
            suggestions.forEach(sugg => { 
                const li = document.createElement('li'); 
                // MODIFIÉ: Texte plus clair
                li.innerHTML = `Remplacer votre saisie <em>${sugg.original}</em> par le jeu déjà existant <strong>${sugg.suggestion}</strong> ?`;
                listElement.appendChild(li); 
            }); 
            const acceptBtn = document.getElementById('modal-accept'); 
            const ignoreBtn = document.getElementById('modal-ignore'); 
            const cancelBtn = document.getElementById('modal-cancel'); 
            
            const cleanup = () => {
                acceptBtn.removeEventListener('click', acceptHandler);
                ignoreBtn.removeEventListener('click', ignoreHandler);
                cancelBtn.removeEventListener('click', cancelHandler);
            };

            const handler = () => { 
                correctionModal.style.display = 'none';
                cleanup();
            }; 
            const acceptHandler = () => { 
                const correctedVotes = JSON.parse(JSON.stringify(voteData.playerVotes)); 
                suggestions.forEach(sugg => { for (const priority in correctedVotes) { correctedVotes[priority] = correctedVotes[priority].map(game => game === sugg.original ? sugg.suggestion : game); } }); 
                saveVote(voteData.userIdToSave, voteData.userNameToSave, correctedVotes, user); 
                handler(); 
            }; 
            const ignoreHandler = () => { 
                saveVote(voteData.userIdToSave, voteData.userNameToSave, voteData.playerVotes, user); 
                if(voteData.userIdToSave === user.uid) { isEditing = false; } // MODIFIÉ
                handler(); 
            };
            const cancelHandler = () => {
                 if(voteData.userIdToSave === user.uid) { isEditing = false; } // MODIFIÉ
                 handler();
            };

            acceptBtn.addEventListener('click', acceptHandler); 
            ignoreBtn.addEventListener('click', ignoreHandler); 
            cancelBtn.addEventListener('click', cancelHandler); 
            correctionModal.style.display = 'flex'; 
        }
        
        function calculateScores(votes) { /* ... */ }
        function animateCounter(element, target) { /* ... */ }
        async function getGameImage(gameName) { /* ... */ }
        async function renderKPIs(gamesData, votes) { /* ... */ }
        function renderTable(gamesData) {  /* ... */ }
        function renderChart(gamesData) { /* ... */ }
        function populateVoterMenu(votes, currentUser) {  /* ... */ }
        function renderDashboard(votes, user) { /* ... */ }
        function renderActiveUsers(users) { /* ... */ }
    }
    
    // NOUVEAU: Fonction pour afficher les notifications
    function showToast(message, type = 'success') {
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        
        container.appendChild(toast);
        
        setTimeout(() => {
            toast.classList.add('show');
        }, 10);

        setTimeout(() => {
            toast.classList.remove('show');
            toast.addEventListener('transitionend', () => toast.remove());
        }, 4000);
    }
});
</script>
</body>
</html>

&lt;/details>

Avec ces changements, votre application devrait être beaucoup plus robuste et agréable à utiliser. Le formulaire ne s'effacera plus de manière inattendue, la logique de fusion sera plus claire pour l'utilisateur, et les confirmations seront élégantes et non-intrusives.

Bon courage pour la suite du développement et profitez bien de votre prochaine LAN !

Je ne crois pas que le fichier index donné soit bon

Tu peux m'indiquer où utiliser la fonction des toast handler là? dans le code ,je remplacerai moi même

Absolument, et toutes mes excuses pour la confusion. Fournir le fichier entier d'un coup peut être indigeste. C'est une bien meilleure approche de pointer précisément les endroits à modifier.

La fonction showToast(message, type) est conçue pour remplacer tous les appels à alert() afin de fournir une notification plus fluide et intégrée.

Voici les endroits exacts dans votre code JavaScript (<script> dans index.html) où vous devriez remplacer les alert() par showToast() :
1. Lors de la soumission réussie d'un vote

    Fonction concernée : saveVote()
    Endroit : Dans le bloc .then() qui se déclenche après la sauvegarde sur Firebase.

JavaScript

function saveVote(userId, userName, playerVotes, user) {
    db.ref(`lan/votes/${userId}`).set({ name: userName, votes: playerVotes })
        .then(() => {
            if (userId === user.uid) {
                isEditing = false;
            }
            if (!correctionModal.style.display.includes('flex')) {
               // À REMPLACER :
               // alert(`Vote pour ${userName} enregistré !`);

               // PAR :
               showToast(`Vote pour ${userName} enregistré !`, 'success');
            }
        })
        .catch(error => {
            console.error("Erreur:", error);
            // BONUS : Vous pouvez aussi notifier l'utilisateur en cas d'échec
            showToast(`Erreur lors de la sauvegarde : ${error.message}`, 'error');
        });
}

2. Lors de la réinitialisation de tous les votes (Panneau Admin)

    Fonction concernée : L'écouteur d'événement sur le bouton reset-all-votes-btn.
    Endroit : Il y a trois cas à gérer ici : la réussite, l'échec et l'annulation.

JavaScript

document.getElementById('reset-all-votes-btn')?.addEventListener('click', () => {
    const confirmation = prompt("Cette action est irréversible et supprimera TOUS les votes. Pour confirmer, tapez 'RESET'.");
    if (confirmation === 'RESET') {
        db.ref('lan/votes').remove()
            // CAS 1 : RÉUSSITE
            .then(() => {
                // À REMPLACER : alert("Tous les votes ont été réinitialisés.");
                // PAR :
                showToast("Tous les votes ont été réinitialisés.", "success");
            })
            // CAS 2 : ÉCHEC
            .catch(err => {
                // À REMPLACER : alert("Erreur lors de la réinitialisation: " + err.message);
                // PAR :
                showToast("Erreur lors de la réinitialisation: " + err.message, "error");
            });
    } else {
        // CAS 3 : ANNULATION
        // À REMPLACER : alert("Action annulée.");
        // PAR :
        showToast("Action annulée."); // Par défaut, le style sera 'success', vous pouvez mettre 'error' si vous préférez
    }
});

En résumé, il vous suffit de rechercher les alert() dans votre code et de les remplacer par un appel à showToast() avec le message approprié et éventuellement un type ('success' ou 'error').

N'oubliez pas que pour que ces appels fonctionnent, le code de la fonction showToast elle-même, les styles CSS correspondants, et le conteneur <div id="toast-container"></div> doivent bien être présents dans votre fichier, comme indiqué dans la réponse précédente.

ça a cassé la connexion, je ne peux plus me connecter au site

Vous avez parfaitement raison, et je suis sincèrement désolé. Une erreur de syntaxe s'est glissée dans le code que je vous ai fourni pour le bouton de réinitialisation. Ce genre d'erreur bloque l'exécution de tout le script JavaScript qui suit, ce qui explique pourquoi même la logique de connexion ne s'activait plus.

Je vous remercie de l'avoir signalé. Corrigeons cela immédiatement.
L'erreur de syntaxe à corriger

Le problème se trouve dans l'écouteur d'événement du bouton reset-all-votes-btn. La syntaxe des fonctions fléchées dans les .then() et .catch() était incorrecte.

Voici le bloc de code à remplacer dans votre fonction initializeApp(user) :

Ancien code défectueux (à supprimer) :
JavaScript

        document.getElementById('reset-all-votes-btn')?.addEventListener('click', () => {
            const confirmation = prompt("Cette action est irréversible et supprimera TOUS les votes. Pour confirmer, tapez 'RESET'.");
            if (confirmation === 'RESET') {
                db.ref('lan/votes').remove()
                    .then(() => showToast("Tous les votes ont été réinitialisés.", "success");}) // Erreur ici
                    .catch(err) => showToast("Erreur lors de la réinitialisation: " + err.message, "error");}) // Et ici
            } else {
               showToast("Action annulée.");
            }
        });

Nouveau code corrigé (à utiliser) :
JavaScript

        document.getElementById('reset-all-votes-btn')?.addEventListener('click', () => {
            const confirmation = prompt("Cette action est irréversible et supprimera TOUS les votes. Pour confirmer, tapez 'RESET'.");
            if (confirmation === 'RESET') {
                db.ref('lan/votes').remove()
                    .then(() => {
                        showToast("Tous les votes ont été réinitialisés.", "success");
                    })
                    .catch((err) => {
                        showToast("Erreur lors de la réinitialisation: " + err.message, "error");
                    });
            } else {
               // On n'affiche le toast que si l'utilisateur a écrit autre chose que "RESET"
               // Si l'utilisateur clique sur "Annuler", la variable `confirmation` est `null`
               if (confirmation !== null) { 
                   showToast("Action annulée.");
               }
            }
        });

Le deuxième problème : La fonction showToast est appelée mais non définie

En regardant à nouveau le fichier, je vois que nous avons bien appelé la fonction showToast, mais son code de définition n'est pas présent. C'est la deuxième erreur qui bloquerait le script.

Veuillez ajouter le bloc de code suivant dans votre balise <script>, par exemple juste avant la fin du script (avant });).
JavaScript

function showToast(message, type = 'success') {
    const container = document.getElementById('toast-container');
    if (!container) return; // Sécurité si le conteneur n'existe pas

    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    
    container.appendChild(toast);
    
    // Animer l'apparition
    setTimeout(() => {
        toast.classList.add('show');
    }, 10); // Un petit délai pour que la transition CSS fonctionne

    // Planifier la disparition
    setTimeout(() => {
        toast.classList.remove('show');
        // Supprimer l'élément du DOM après la fin de l'animation pour ne pas surcharger la page
        toast.addEventListener('transitionend', () => toast.remove());
    }, 4000); // Le toast reste visible 4 secondes
}

Pour résumer :

    Remplacez le code de l'écouteur d'événement reset-all-votes-btn par la version corrigée.
    Ajoutez la définition de la fonction showToast dans votre script.

Ces deux corrections résoudront l'erreur de syntaxe qui empêchait la connexion et rendront les notifications fonctionnelles. Je vous présente à nouveau mes excuses pour cette erreur.

2 petits bugs:


- pourquoi la liste des jeux à gauche ne s'affiche pas dans l'ordre du classement? C'est gênant

- j'ai 2 fois call of duty black ops 6 pour le coup, écrits de la même manière a priori. On est bon sur les doublons dans le code?

Bonjour ! Analysons ces deux nouveaux points. Ce sont d'excellentes observations qui vont nous permettre de peaufiner l'application.
1. Pourquoi la liste à gauche n'est pas dans l'ordre du classement ?

C'est une excellente question qui révèle une petite confusion sur la fonctionnalité de cette barre latérale.

Explication :
La barre qui s'affiche à gauche n'est pas une liste des jeux, mais une liste des utilisateurs actuellement connectés sur le site. Chaque icône est l'avatar Google de la personne active. Son but est de voir en temps réel qui participe à la session de vote.

Le code qui gère cette partie est la fonction renderActiveUsers : elle parcourt une liste de statuts d'utilisateurs (/status/ dans Firebase) et affiche leur avatar, sans aucun lien avec le classement des jeux.

Ceci étant dit, votre idée d'avoir une liste des jeux les mieux classés visible en permanence est très bonne ! Ce serait une nouvelle fonctionnalité à développer, par exemple en créant une autre fonction renderTopGamesSidebar qui, elle, prendrait la liste des jeux triée pour l'afficher.
2. Doublons pour "Call of Duty Black Ops 6"

Vous avez mis le doigt sur un problème de fond très courant : la normalisation des données. Même si les deux textes semblent identiques, une différence de majuscule ou un double espace invisible suffit à ce que le programme les considère comme deux jeux distincts.

Cause du problème :
Actuellement, le calcul des scores dans la fonction calculateScores est sensible à la casse (majuscules/minuscules) et aux espaces. "Call of Duty" et "call of duty" sont traités comme deux entrées différentes, d'où le dédoublement des scores.

Solution :
Nous allons créer une fonction de "normalisation" qui formatera chaque nom de jeu de manière identique (tout en minuscules, sans espaces superflus) avant de le sauvegarder et avant de calculer les scores.

Voici les 2 modifications à apporter à votre code :
Étape 1 : Créer la fonction de normalisation

Ajoutez cette petite fonction utilitaire au début de votre section <script>, juste après les constantes ADMIN_UID.
JavaScript

// ...
const ADMIN_UID = "ITe5VPuwewMzO7JnJA5oPWMdfvt2"; // Remplacez par votre UID Firebase

// NOUVEAU : Fonction pour nettoyer les noms de jeux
const normalizeGameName = (name) => {
    if (typeof name !== 'string') return '';
    // Met en minuscule, supprime les espaces au début/fin, et remplace les espaces multiples par un seul
    return name.trim().toLowerCase().replace(/\s+/g, ' ');
}

// --- INITIALISATION ---
// ...

Étape 2 : Utiliser la normalisation lors de la soumission du vote

Modifiez la ligne où vous récupérez la valeur de l'input dans l'écouteur d'événement du formulaire vote-form.

    Fonction concernée : L'écouteur voteForm.addEventListener('submit', ...)
    Modification :

JavaScript

        voteForm.addEventListener('submit', (e) => {
            // ...
            document.querySelectorAll('.priority-group').forEach(group => {
                const priority = group.dataset.priority;
                group.querySelectorAll('.game-input-list input').forEach(input => {
                    // À MODIFIER :
                    const game = normalizeGameName(input.value); // On utilise notre nouvelle fonction
                    if(game) {
                        playerVotes[priority].push(game);
                        allNewGames.add(game);
                    }
                });
            });
            // ...
        });

Étape 3 : Utiliser la normalisation pour le calcul des scores

Cela garantit que les anciens votes (qui n'étaient peut-être pas normalisés) sont correctement regroupés avec les nouveaux.

    Fonction concernée : calculateScores(votes)
    Modification :

JavaScript

function calculateScores(votes) { 
    const gameScores = {}; 
    const pointsMapping = { p1: 5, p2: 3, p3: 2, p_other: 1 }; 
    for (const userId in votes) { 
        const voteData = votes[userId]; 
        if(voteData && voteData.votes) { 
            for (const priority in voteData.votes) { 
                voteData.votes[priority].forEach(game => {
                    // À MODIFIER :
                    const normalizedGame = normalizeGameName(game);
                    if (normalizedGame) {
                        gameScores[normalizedGame] = (gameScores[normalizedGame] || 0) + pointsMapping[priority]; 
                    }
                }); 
            } 
        } 
    } 
    // On doit reconstruire les noms avec une majuscule pour l'affichage
    const finalScores = {};
    Object.keys(gameScores).forEach(name => {
        const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
        finalScores[capitalizedName] = gameScores[name];
    });

    return Object.entries(finalScores).map(([name, score]) => ({ name, score })).sort((a, b) => b.score - a.score);
}

Attention : La modification de la fonction calculateScores va regrouper tous les jeux (par exemple "call of duty" et "Call Of Duty") sous une seule entrée en minuscule (call of duty). Pour l'affichage, il est plus joli d'avoir une majuscule. La version ci-dessus a été améliorée pour remettre une majuscule au premier mot du jeu avant de retourner le classement final.

Avec ces changements, le problème des doublons sera définitivement réglé !

Ok merci mais je parle de cette barre latérale. Il n'y a pas de classements ordonné


En outre, sur la barre des users connectées ,une amie qui a testé et s'est déco apparaît toujours là. BUg?

Vous avez tout à fait raison, et je vous prie d'accepter mes excuses. J'ai mal interprété votre première remarque. L'image que vous avez envoyée est très claire : c'est bien le tableau principal du classement qui n'est pas ordonné correctement, et non la barre latérale des utilisateurs.

Analysons et corrigeons ces deux bugs.
1. Le tableau "Classement & Scores" n'est pas trié

Le problème est très subtil et est un piège classique en JavaScript.

Cause du problème :
Dans la fonction renderTable, vous utilisez une boucle forEach avec une fonction async à l'intérieur pour récupérer l'image de chaque jeu (await getGameImage(game.name)).
Le souci est que la boucle forEach n'attend pas la fin d'une opération await avant de passer à l'itération suivante. Elle lance toutes les requêtes pour récupérer les images en parallèle. Les lignes du tableau sont ensuite ajoutées au fur et à mesure que les images arrivent du réseau, et non dans l'ordre du classement.

La solution :
Nous devons remplacer la boucle forEach par une boucle for...of, qui, elle, respecte et attend la fin de chaque await avant de continuer.

Modification à apporter :
Remplacez entièrement votre fonction renderTable par celle-ci.
JavaScript

        function renderTable(gamesData) { 
            const tableBody = document.getElementById('results-table-body');
            tableBody.innerHTML = '';
            if (gamesData.length === 0) { 
                tableBody.innerHTML = `<tr><td colspan="2" style="text-align: center;">Aucun vote pour le moment...</td></tr>`; 
                return;
            }

            // CORRECTION : Remplacement de forEach par une boucle for...of qui attend l'await
            let rank = 1;
            for (const game of gamesData) { 
                const row = document.createElement('tr');
                // L'animation est maintenant gérée par la classe, pas par le délai JS
                // row.style.animationDelay = `${index * 0.05}s`;

                if (rank === 1) row.classList.add('gold');
                else if (rank === 2) row.classList.add('silver');
                else if (rank === 3) row.classList.add('bronze');
                
                const gameCell = document.createElement('td');
                const scoreCell = document.createElement('td');
                
                const gameIcon = document.createElement('img');
                // L'await va maintenant bien mettre en pause la boucle
                gameIcon.src = await getGameImage(game.name);
                gameIcon.alt = 'Icone';
                gameIcon.className = 'game-icon';
                
                gameCell.appendChild(gameIcon);
                gameCell.append(`${rank}. ${game.name}`);
                scoreCell.textContent = game.score;
                
                row.appendChild(gameCell);
                row.appendChild(scoreCell);
                tableBody.appendChild(row);

                rank++; // On incrémente le rang pour le prochain tour
            }
        }

Avec cette correction, les jeux s'afficheront dans l'ordre décroissant de leur score.
2. Un utilisateur déconnecté reste visible dans la barre des connectés

Ceci est également un bug de logique très pertinent.

Cause du problème :
La fonction onDisconnect().remove() est conçue pour s'activer quand la connexion au serveur Firebase est brutalement coupée (fermeture de l'onglet, perte de réseau, etc.). Cependant, lorsque l'utilisateur clique sur le bouton "Déconnexion", il ne se déconnecte pas brutalement : il effectue une action de signOut() propre. Dans ce cas, la commande onDisconnect n'est pas déclenchée, et son statut reste dans la base de données.

La solution :
Nous devons manuellement supprimer le statut de l'utilisateur de la base de données juste avant de le déconnecter via signOut().

Modification à apporter :
Trouvez l'écouteur d'événement pour le bouton de déconnexion et ajoutez une ligne pour supprimer le statut.
JavaScript

    // Dans la fonction `DOMContentLoaded`
    logoutBtn.addEventListener('click', () => {
        // CORRECTION : On supprime manuellement le statut de l'utilisateur avant la déconnexion
        const user = auth.currentUser;
        if (user) {
            db.ref('/status/' + user.uid).remove();
        }
        auth.signOut();
    });

Cette modification garantit que, que l'utilisateur se déconnecte manuellement ou ferme son navigateur, son avatar disparaîtra bien de la liste des utilisateurs actifs.

Uncaught SyntaxError: await is only valid in async functions, async generators and modules

Toutes mes excuses, c'est une nouvelle erreur d'inattention de ma part. Vous avez raison, et le message d'erreur est très clair. J'ai corrigé le problème de la boucle, mais j'ai oublié une étape essentielle.

Cause de l'erreur :
L'erreur await is only valid in async functions signifie exactement ce qu'elle dit. Nous avons mis le mot-clé await dans la fonction renderTable pour attendre l'image du jeu, mais nous n'avons jamais déclaré la fonction renderTable elle-même comme étant asynchrone (async).

La solution en cascade :
Pour corriger cela, il ne suffit pas d'ajouter async à renderTable. Nous devons nous assurer que toute la chaîne d'appel est cohérente.

    renderTable doit devenir async.
    Par conséquent, la fonction qui l'appelle, renderDashboard, doit aussi devenir async pour pouvoir await la fin du rendu de la table.
    Et finalement, la fonction qui appelle renderDashboard (la fonction callback de l'écouteur Firebase) doit également devenir async.

Voici les 3 modifications précises à apporter.
1. Modifier la fonction renderTable

Ajoutez simplement le mot-clé async devant la définition de la fonction.
JavaScript

// DEVIENT :
async function renderTable(gamesData) { 
    const tableBody = document.getElementById('results-table-body');
    tableBody.innerHTML = '';
    if (gamesData.length === 0) { 
        tableBody.innerHTML = `<tr><td colspan="2" style="text-align: center;">Aucun vote pour le moment...</td></tr>`; 
        return;
    }

    let rank = 1;
    for (const game of gamesData) { 
        const row = document.createElement('tr');

        if (rank === 1) row.classList.add('gold');
        else if (rank === 2) row.classList.add('silver');
        else if (rank === 3) row.classList.add('bronze');
        
        const gameCell = document.createElement('td');
        const scoreCell = document.createElement('td');
        
        const gameIcon = document.createElement('img');
        gameIcon.src = await getGameImage(game.name); // Ce await nécessite le async sur la fonction
        gameIcon.alt = 'Icone';
        gameIcon.className = 'game-icon';
        
        gameCell.appendChild(gameIcon);
        gameCell.append(`${rank}. ${game.name}`);
        scoreCell.textContent = game.score;
        
        row.appendChild(gameCell);
        row.appendChild(scoreCell);
        tableBody.appendChild(row);

        rank++;
    }
}

2. Modifier la fonction renderDashboard

Ajoutez async à sa définition et await devant les appels aux fonctions qui sont maintenant asynchrones (renderKPIs et renderTable).
JavaScript

// DEVIENT :
async function renderDashboard(votes, user) {
    const sortedGames = calculateScores(votes);
    populateVoterMenu(votes, user);
    // On attend que les fonctions async se terminent
    await renderKPIs(sortedGames, votes);
    await renderTable(sortedGames);
    renderChart(sortedGames); // renderChart n'est pas async, pas besoin d'await
}

3. Modifier l'écouteur Firebase votesRef.on('value', ...)

Enfin, ajoutez async à la fonction callback de l'écouteur pour pouvoir utiliser await sur renderDashboard.

    Fonction concernée : initializeApp(user)
    Modification :

JavaScript

// Dans initializeApp(user)
// ...
        if (votesRef) votesRef.off();
        votesRef = db.ref('lan/votes');
        // On ajoute async à la fonction fléchée ici
        votesRef.on('value', async (snapshot) => {
            globalVotes = snapshot.val() || {};
            // Et on attend que le rendu complet soit fait
            await renderDashboard(globalVotes, user); 
            
            const selectedUserId = voterSelectMenu.value || user.uid;
            if (!isEditing || selectedUserId !== user.uid) {
                loadVoteIntoForm(selectedUserId, globalVotes, user);
            }
        });
// ...

Avec ces trois modifications, la chaîne d'asynchronisme sera correctement gérée, l'erreur disparaîtra et votre interface se mettra à jour de manière fiable et dans le bon ordre.

Encore désolé pour ces oublis successifs. Nous nous approchons d'une version stable !

ça marche plutôt bien, mais tu devrais ajouter une option de chargement pour les charts du coup

Parce que le temps que le dashboard s'affiche (il doit DL tout depuis steam), les charts ne sont pas là et on a l'impression que ça bug

Soit tu affiches tout en te basant que sur nos données, et petit à petit les icônes se maj

Soit tu affiches les charts qu'après un temps de chargement

Excellente remarque, c'est un point très important pour l'expérience utilisateur (UX). Vous avez raison, l'attente sans indication de chargement donne l'impression que l'application a un problème.

Les deux solutions que vous proposez sont les approches standards pour gérer ce cas de figure. La première, qui consiste à afficher les données textuelles immédiatement et à charger les images ensuite, est souvent celle qui offre la meilleure perception de rapidité.

Implémentons donc votre première suggestion.
La solution : Affichage immédiat et chargement progressif des images

Nous allons modifier la logique pour que le tableau et les KPIs s'affichent instantanément avec les noms et les scores. Les requêtes pour obtenir les images des jeux seront lancées en arrière-plan, et les icônes s'afficheront au fur et à mesure qu'elles seront téléchargées, sans bloquer le reste de l'interface.

Pour cela, nous allons "désynchroniser" les fonctions de rendu.

Voici les modifications à apporter à votre script :
1. Modifier la fonction renderKPIs

Elle n'a plus besoin d'être async. Elle affichera le nom du gagnant immédiatement, et mettra à jour l'image quand elle sera disponible.
JavaScript

// DEVIENT :
function renderKPIs(gamesData, votes) { // On retire "async"
    const winnerName = gamesData.length > 0 ? gamesData[0].name : '--';
    document.getElementById('kpi-winner-value').textContent = winnerName;
    const winnerImage = document.getElementById('winner-image');
    
    // On réinitialise l'image
    winnerImage.classList.remove('loaded');
    winnerImage.src = ''; 

    if (winnerName !== '--') {
        // On lance la récupération de l'image mais on n'attend pas la réponse
        getGameImage(winnerName).then(imageUrl => {
            // Cette partie s'exécutera quand l'image sera téléchargée
            winnerImage.src = imageUrl;
            if (imageUrl.startsWith('https')) { // On ne met l'effet que pour les vraies images
                winnerImage.classList.add('loaded');
            }
        });
    }

    animateCounter(document.getElementById('kpi-voters-value'), Object.keys(votes).length);
    animateCounter(document.getElementById('kpi-games-value'), gamesData.length);
}

2. Modifier la fonction renderTable

Même principe : on retire async, on affiche la ligne de tableau tout de suite avec une icône par défaut, puis on met à jour l'icône une fois téléchargée.
JavaScript

// DEVIENT :
function renderTable(gamesData) { // On retire "async"
    const tableBody = document.getElementById('results-table-body');
    tableBody.innerHTML = '';
    if (gamesData.length === 0) {
        tableBody.innerHTML = `<tr><td colspan="2" style="text-align: center;">Aucun vote pour le moment...</td></tr>`;
        return;
    }

    gamesData.forEach((game, index) => { // on peut réutiliser forEach sans souci
        const row = document.createElement('tr');
        const rank = index + 1;

        if (rank === 1) row.classList.add('gold');
        else if (rank === 2) row.classList.add('silver');
        else if (rank === 3) row.classList.add('bronze');

        const gameCell = document.createElement('td');
        const scoreCell = document.createElement('td');

        const gameIcon = document.createElement('img');
        gameIcon.alt = 'Icone';
        gameIcon.className = 'game-icon';
        // On met une icône par défaut immédiatement
        gameIcon.src = DEFAULT_GAME_ICON;

        // On lance la récupération de l'image en arrière-plan
        getGameImage(game.name).then(imageUrl => {
            // Et on la met à jour quand elle est prête
            gameIcon.src = imageUrl;
        });

        gameCell.appendChild(gameIcon);
        gameCell.append(`${rank}. ${game.name}`);
        scoreCell.textContent = game.score;

        row.appendChild(gameCell);
        row.appendChild(scoreCell);
        tableBody.appendChild(row);
    });
}

        function renderChart(gamesData) { 
            const chartContainer = document.getElementById('chart-container');
            chartContainer.innerHTML = '';
            const topGames = gamesData.slice(0, 8);
            if (topGames.length === 0) return;
            
            const maxScore = topGames[0].score;
            
            topGames.forEach((game, index) => {
                const barHeight = maxScore > 0 ? (game.score / maxScore) * 100 : 0;
                
                const barGroup = document.createElement('div');
                barGroup.className = 'chart-bar-group';
                barGroup.style.animationDelay = `${0.5 + index * 0.1}s`;
                
                const bar = document.createElement('div');
                bar.className = 'chart-bar';
                bar.style.height = `${barHeight}%`;
                
                const barLabel = document.createElement('div');
                barLabel.className = 'bar-label';
                const crown = index === 0 ? '👑' : '';
                barLabel.textContent = `${game.score} ${crown}`;
                
                const gameNameLabel = document.createElement('div');
                gameNameLabel.className = 'chart-game-name';
                gameNameLabel.textContent = game.name;

                if (index === 0) barGroup.classList.add('gold');
                else if (index === 1) barGroup.classList.add('silver');
                else if (index === 2) barGroup.classList.add('bronze');
                
                bar.appendChild(barLabel);
                barGroup.appendChild(bar);
                barGroup.appendChild(gameNameLabel);
                chartContainer.appendChild(barGroup);
            });
        }
        
        function populateVoterMenu(votes, currentUser) { 
            const currentSelection = voterSelectMenu.value; 
            voterSelectMenu.innerHTML = '<option value="">-- Mon Vote --</option>'; 
            const sortedVoters = Object.entries(votes).sort((a,b) => a[1].name.localeCompare(b[1].name)); 
            sortedVoters.forEach(([uid, voteData]) => { 
                if (uid === currentUser.uid) return; 
                const option = document.createElement('option'); 
                option.value = uid; 
                option.textContent = voteData.name; 
                voterSelectMenu.appendChild(option); 
            }); 
            voterSelectMenu.value = currentSelection;
        }
        
        function renderDashboard(votes, user) { // On retire "async"
    const sortedGames = calculateScores(votes);
    populateVoterMenu(votes, user);
    // On retire les "await" car les fonctions ne sont plus bloquantes
    renderKPIs(sortedGames, votes);
    renderTable(sortedGames);F
    renderChart(sortedGames);
}
    }
});
</script>
    <div id="toast-container"></div>
</body>
</html>